### 무상태란 무엇인가?<br>
무상태란 http의 특징중 하나로 서버는 클라이언트의 상태를 기억하지 않음을 말한다. 
클라이언트에서 서버에게 정보를 전달하므로 클라이언트를 기억할 필요가 없는 서버는 여러대로 확장되어도 문제가 없다.<br>
### 무상태를 언제 사용하면 좋을까?<br>
무상태는 http의 특징이므로 http통신을 하는 모든 순간에 사용한다.<br>
### 상태 유지는 언제 해야하나?<br>
서버가 클라이언트의 상태를 기억해야 할때 하는데, 로그인 유지나 팝업창등에서 쿠키나 세션을 통해서 기억한다.<br>
### 스케일 업, 스케일 아웃<br>
서버를 운영할때 이용자가 증가하거나 사업을 확장할 때 많은 서버의 용량과 성능이 필요한데, 이때 스케일 업과
스케일 아웃을 사용한다. 단순히, 서버 교체작업이기 때문에 구현과 설계가 쉽다는 장점이 있다.
 성능, 확장의 한계가 있으며 서버가 고장났을 경우 복구될때까지 서비스를 중단해야 하는 상황이 발생할 수 있다.<br>
스케일 업은 기존 서버의 사양을 업그레이드 해서 시스템을 확장하는 방법으로 CPU나 RAM등을 추가하여 고성능의 서버로
교환하는 방법이다.<br>
스케일 아웃은 서버 컴퓨터를 여러대 추가하여 시스템을 확장하는것을 말한다. 따라서 하나
의 서버가 고장나더라도 다른 서버를 사용해 서비스를 중단하는 일이 적다. 스케일 아웃
을 사용하면 서버에 균등한 부하를 주는 로드 밸런싱을 해줘야 한다. 로드 밸런서는 서버
풀과 클라이언트 사이에 존재한다. 이때 로드 밸런싱 방법 은 라운드로빈 방식, 가중 라운드로빈 방식, IP해시 방식, 최소 연결방식, 최소 리스폰타임
이 있다.<br>
라운드로빈 방식: 서버에 들어온 요청을 순서대로 돌아가면서 배정하는 방식이다. 세션이 오래지속되지 않는	경우에
활용이 적합하다.<br>
가중 라운드로빈 방식: 서버에 가중치를 부과하여 가중치대로 요청을 배정하는 방식이다.  예를들어 가중치가 5, 2인
서버가 있을 때 가중치가 5인 서버에 5개의 요청, 2인 서버에 2개의 요청을 전달한다.<br>
IP해시 방식: 특정 클라이언트의 IP를 특정 서버로 매핑하여 요청을 처리하는 방식이다. 따라서 특정 클라
이언트는 항상 같은 서버와 연결된다.<br>
최소 연결 방식: 클라이언트가 요청한 시점에 가장 적은 연결상태를 보이는 서버에 우선으로 응답하는 방식이다.<br>
최소 리스폰타임: 서버의 연결상태, 응당시간을 모두 고려한 방식으로 연결이 가장 적은 서버 + 가장 짧은 응답시간을
보이는 서버에 가장 우선적으로 연결한다.<br>
로드밸런서는 L4로드밸런서와 L7로드 밸런서를 이용하는데 이유는 L4로드밸런서 부터 서버에 포트정보
를 바탕으로 로드를 분산하는것이 가능하기 때문이다.<br>
L4 로드밸런서: TCP, UDP 포트 정보를 바탕으로 한다. 따라서 데이터 안을 들여다보지 않고 패킷
레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 좋다는 장점이 있지만, 패킷의 내용을
살펴볼 수 없기 때문에 섬세한 라우팅이 불가능하며, 사용자의 IP가 수시로 바뀌는 경우라면 연속
적인 서비스를 제공하기 어렵다.<br>
L7 로드밸런서: 애플리케이션 계층(HTTP)에서 로드를 분산하기 때문에 HTTP헤더, 쿠키등과 같은 사
용자의 요청을 기준으로 특정 서버에서 트래픽을 분산하는것이 가능하다.<br>
### 쿠키, 세션<br>
쿠키란 클라이언트에 저장되는 데이터 파일이다. 페이지 요청시 서버에서 쿠키를 생성하여 HTTP
헤더이 담아 응답한다. 클라이언트에서는 이 쿠키를 갖고 있다가 요청할때마다 HTTP헤더에 담아
요청한다.<br>
세션이란 일정 시간(브라우저가 종료되는 시점)동안 서버와 클라이언트간 연결을 유지시키는 기술
인데 이때 페이지 요청시 서버에서 세션아이디를 발급하여 사용자의 정보를 서버에 저장한 후 쿠키에
세션아이디를 담아 클라이언트를 구분짓는다.<br>
### 비연결성이란 무엇인가?<br>
비연결성이란 HTTP의 특징중 하나로 HTTP통신시 요청과 응답이 끝나면 연결을 끊어버리는 것을 
의미한다.<br>
### TCP는 연결성인데 HTTP는 왜 비연결성인가?<br>
이는 TCP와 HTTP의 개념의 차이인데, HTTP통신을 할때 전송계층해서 TCP가 HTTP메시지를 패킷
단위로 분해를한다. 따라서 TCP라는 프로토콜의 특징으로 인해 데이터 전송시 3WAY 핸드쉐이크
를 통해 연결을 설정하여 데이터의 순서, 신뢰도가 보장이 된다. HTTP가 비연결성인 이유는 우리가 HTTP통신을 할
때 연결을 유지할 필요가 없기 때문이다. <br>
- https?<br>
https란 http에 보안의 기능을 추가한 것인데, 클라이언트가 서버에 페이지를 요청하면 서버는 인증
서(CA)를 브라우저에 보내고, 브라우저는 인증서의 유효성을 검사한 후 세션키를 발급한다. 이후
세션키를 서버의 공개키로 암호화 한 후, 서버로 보낸다. 서버에서는 세션키를 서버가 갖고있는
개인키로 복호화를 하고 클라이언트간 데이터를 교환한다.<br>
* TLS<br>
TLS(Transport Layer Secure)은 인터넷상의 커뮤니케이션을 위한 보안 프로토콜이다. SSL의 발전
한 버전으로 HTTPS는 HTTP프로토콜 상위에서 TLS암호화를 구현한 것으로 모든 웹사이트에서
사용된다.<br>
### KeepAlive<br>
HTTP는 비연결성의 특징을 가지고 있다. 따라서 클라이언트와 서버가 한번의 통신이 끝나면 연결
을 끊어버린다. 따라서 매 요청마다 3-way handshake과정을 거친다. 하지만 HTTP/1.1부터는 이미
연결되어있는 TCP연결을 재사용하는 Keep-Alive기능을 지원한다. HTTP헤더에 Kepp-Alive를 담아
보내주면 연결된 Socket(종착점)에 마지막으로 Access된 시간으로부터 정해진 시간까지 연결이
없으면 해제되는 식으로 작동이 된다.<br>
장점: hankdShake과정을 생략하므로 속도가 더 빠르다. <br>
단점: 하나의 웹서버에 여러 클라이언트가 연결을 유지하고 있으면 성능이 저하된다. 따라서 대량
접속이 일어날때 문제가 발생한다.<br>
문제점: 일반적으로 HTTP는 클라이언트와 서버 사이에 프록시 서버와 같은 중개서버가 존재한다.
이때 프록시 서버는 keep-alive를 모르기 때문에 연결이 끊기기를 계속 기다리다 타임아웃이 되는
상황이 발생한다. 따라서 이를 위해 proxy-connection이라는 확장 헤더를 프록시에 전달하는 방법
을 사용한다.
### HTTP Version<br>
* HTTP 0.9<br>
HTTP 초기 버전을 구분하기 위해 부르는 버전 (1991년)<br>
요청은 단일 라인으로 구성되며, 리소스에 대한 method는 GET만 존재<br>
응답도 극도로 단순 (파일 내용 자체로만 구성)<br>
HTTP 헤더도 없고, HTML파일만 전송 가능했던 것이 특징<br>
```
GET /mypage.html

/* 응답 */
<HTML>
A very simple HTML page
</HTML>
```
* HTTP 1.0<br>
특징<br>
HTTP 헤더(header) 개념이 도입되어 요청과 응답에 추가되며, 메타데이터를 주고 받고 프로토콜을 유연하고 확장 가능하도록 개선됨 (1996년)<br>
버전 정보와 요청 method가 함께 전송되기 시작<br>
상태 코드 라인도 응답의 시작부분에 추가되어 브라우저 요청의 성공과 실패를 파악 가능해짐<br>
(해당 결과에 대한 로컬 캐시 갱신 등의 사용이 가능해짐)<br>
Content-Type 도입으로 HTML 이외의 문서 전송 기능이 가능해짐<br>

한계
<br>
커넥션 하나당 요청 하나와 응답 하나만 처리 가능했음<br>
-> 지금 생각해보면 매우 비효율적인 동작으로 보이며, 서버 부하도 문제<br>
-> HTTP 1.1에서 개선<br>
```
/* 요청 */
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

/* 응답 */
200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
<HTML>
A page with an image
  <IMG SRC="/myimage.gif">
</HTML>
```
* HTTP1.1<br>
특징<br>
1997년 등장<br>
Persistent Connection 추가<br>
지정한 timemout 동안 커넥션을 닫지 않는 방법을 통해 커넥션의 사용성이 높아짐<br>
Pipelining 추가<br>
앞 요청의 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내고 그 순서에 맞춰 응답을 받는 방식이 등장<br>
순차적으로 하나씩 요청 / 응답이 처리되는 기존 방식을 개선<br>
하나의 커넥션에 여러개의 요청이 들어 있을 뿐, 동시에 여러개의 요청을 처리해 응답으로 보내주는 것은 아니다 (multiplexing 되지는 않음)<br>
한계<br>
Head Of Line Blocking (HOL)<br>
: 결국 앞 요청의 응답이 너무 오래걸리면 뒤 요청은 Blocking 되어버림<br>
Header 구조의 중복<br>
: 연속된 요청의 헤더의 많은 중복이 발생<br>
```
/* 요청 */
GET /en-US/docs/Glossary/Simple_header HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

/* 응답 */
200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Wed, 20 Jul 2016 10:55:30 GMT
Etag: "547fa7e369ef56031dd3bff2ace9fc0832eb251a"
Keep-Alive: timeout=5, max=1000
Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
Server: Apache
Transfer-Encoding: chunked
Vary: Cookie, Accept-Encoding

(content)
```	
* HTTP 2.0<br>
설명<br>
기존 HTTP 1.X 버전의 성능 향상에 초점을 맞춘 프로토콜 (2015년 등장)<br>
표준의 대체가 아닌 확장 (표준 : HTTP 1.1)<br>
```
특징
1) HTTP 메시지 전송 방식의 전환
2) Multiplexed Streams
3) Stream Prioritization
4) Server Push
5) Header Compression
HTTP 메시지 전송 방식의 전환
기존 : 일반 텍스트 형식
개선
Binary Framing 계층을 추가해서 보내는 메시지를 프레임(frame)이라는 단위로 분할하며 추가적으로 바이너리로 인코딩을 한다
(바이너리 형식 사용으로 파싱속도 및 전송 속도가 빠르고 오류 발생 가능성이 낮아짐)
Multiplexed Streams
기존 : HTTP 1.1의 Pipelining 으로 하나의 커넥션에 여러 요청이 있지만, 결국 동시에 여러 요청을 처리해 응답으로 주지는 못하였음
개선
구성된 연결 내에 전달되는 바이트의 양방향 흐름을 의미하는 Stream으로 요청 / 응답이 교환됨
(하나의 커넥션 안에 여러개의 Stream 존재 가능)
메시지가 이진화된 텍스트인 프레임(frame)으로 나뉘어 요청마다 구분되는 Stream을 통해 전달
즉, 프레임(frame)이 각 요청의 스트림(stream)을 통해 전달되며, 하나의 커넥션 안에 여러개의 스트림(stream)을 가질 수 있게되어 다중화(multiplexing)가 가능해짐
-> 동시에 여러 요청을 처리하는 것이 가능해짐
-> Stream을 통해서 각 요청의 응답의 순서가 의미가 없어져서 HOL Blocking이 자연스럽게 해결됨
Stream Prioritization
리소스간 우선순위를 설정하는 기능
Stream에 우선순위를 부여해서 인터리빙되고 전달하는 것이 가능해짐
Server Push
단일 클라이언트 요청에 여러 응답을 보낼 수 있는 특징을 통해 Server에서 client에게 필요한 추가적인 리소스를 push해주는 기능
Header Compression
기존 : 연속된 요청의 경우 많은 중복된 헤더의 전송으로 오버헤드가 많이발생했음
개선
요청과 응답의 헤더 메타데이터를 압축해서 오버헤드를 감소
1) 전송되는 헤더 필드를 static dynamic table로 서버에서 유지
2) 이전에 표시된 헤더를 제외한 필드를 허프만(huffman) 인코딩을 수행해서 데이터를 압축
[ HTTP 2.0 한계 ]
각 요청마다 Stream으로 구분해서 병렬적으로 처리하지만,
결국 이에는 TCP 고유의 HOL Blocking이 존재
왜냐하면, 서로 다른 Stream이 전송되고 있을 때, 하나의 Stream에서 유실이 발생되거나 문제가 생기면 결국 다른 Stream도 문제가 해결될 때 까지 지연되는 현상이 발생되기 때문
즉, 이러한 TCP의 태생적인 HOL Blocking을 해결하기 위해 QUIC / HTTP3.0이 등장
```
* QUIC / HTTP 3.0<br>
```
QUIC ?
Google에서 개발한 UDP 기반의 전송 프로토콜 (Quick UDP Internet Connections)
Google에서 TCP의 구조적 문제로 성능 향상이 어렵다고 판단하여 UDP 기반을 선택
QUIC은 TCP의 3-way handshake과정을 최적화 하는 것에 초점을 두고 개발됨
QUIC은 TCP의 Stream은 하나의 chain으로 연결되는 것과 다르게 각 Stream당 독립된 Stream chain을 구성하여 TCP HOL Blocking을 해결하였다
HTTP 3.0
QUIC을 기반으로 나온 새로운 HTTP 메이저 버전
```

### 쿠키
* 쿠키의 유효시간은?<br>
쿠키는 개발자가 정해준 시간이 지나면 자동으로 삭제된다.<br>
* 쿠키가 어디에 사용되나<br>
쿠키는 보통 로그인, 7일간 보지않음(팝업), 인터넷 사용기록 등에 이용된다.<br>
* 세션<br>
* 세션 아이디는 무엇인가?<br>
세션아이디란 서버에서 클라이언트를 구분짓기 위해 발급하는 아이디로 클라이언트에서 최초로
서버에 요청시 세션아이디를 발급하여 쿠키에 담아 클라이언트에 보낸다. 클라이언트에서는 요
청마다 본인의 세션아이디를 쿠키에 담아 서버로 전송한다.<br>
쿠키가 보안에 취약함에도 불구하고 사용하는 이유는 사용자의 정보를 브라우저에 저장
할 수 있기 때문이다. 서버의 용량은 제한되어 있기에 모든 클라이언트의 정보를 저장하
기에는 제한이 되어있다. 따라서 중요한 정보는 세션을 이용하는것이 좋다. 세션하이재
킹을 당하더라도 아이디와 비밀번호가 해킹되는것이 아닌 로그인한 상태를 해킹당하는
것이기 때문에 사용자의 아이디와 비밀번호가 노출되는 일은 없다.