### 데이터베이스를 왜 사용할까?<br>
처음에는 파일 단위로 저장을 했지만, 파일 단위로 저장할때 데이터 종속성, 중복성, 데이트 무결성 문제가 존재하기 때문에 사용하기 시작했다. <br>
데이터베이스의 특징으로 데이터의 독립성, 데이터의 무결성, 데이터의 보안성, 데이터의 일관
성이 있다 <br><br>
데이터의 독립성<br>
데이터베이스의 사이즈를 늘리거나, 성능 향상을 위해 데이터 파일을 늘리거나 새로 추가해도 관련된 응용 프로그램응 수정할 필요가 없다.<br><br>
데이터의 무결성<br>
여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.<br><br>
데이터의 보안성<br>
인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.<br><br>
데이터의 일관성<br>
관된 정보를 논리적은 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다.
또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.<br><br>
데이터 중복 최소화<br>
데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.<br><br>
### JDBC<br>
JDBC란 Java Data Base Connection의 줄임말로 자바 어플리케이션과 데이터베이스의 연결을 위해
사용하는 API이다.
### API<br>
API란 특정 기능을 제공하는 소프트웨어 인터페이스이다.<br>
### 라이브러리 vs 프레임워크<br>
라이브러리란 응용프로그램 개발을 위해 필요한 기능을 모아 놓은 소프트웨어이다.<br>
프레임워크란 응용프로그램이나 소프트웨어 구현을 수월하게 하기 위해 제공된 소프트웨어
환경이다.<br>
라이브러리와 프레임워크의 차이점은 흐름을 누가 가지고 있는가의 차이이다. 프레임워크는
전체적인 흐름을 갖고 있어 프로그래머는 그 안에서 필요한 코드를 작성한다. 라이브러리는
개발자가 흐름을 갖고 있어 원하는 기능을 구현하고 싶을때 라이브러리를 사용할 수 있다.
프레임워크는 가져다 사용한다는 개념보다는 프레임워크라는 공간에서 사용한다는 느낌이 더
강하다. 대표적으로 Spring, django, Node.js가 있다.
### Connection Pool<br>
Connection Pool이란 Connection을 담아놓은 pool을 말하는데 데이터베이스와 어플리케이션
을 연동할때 커넥션을 생성하고 종료하는것이 아닌 풀에다가 케녁션을 넣어놓고 필요할때 마다
꺼내서 사용하고 사용이 끝나면 pool에 반납하는 식이다.<br>
###Thread Pool<br>
스레드 풀은 작업처리에 사용되는 스레드를 제한된 개수만큼 정해놓고 작업큐 (Queue)에 들어
오는 작업들을 하나씩 스레드가 맡아 처리한다. 그렇게 하면 작업처리 요청이 폭증되어도 스레
드의 전체개수가 늘어나지 않으므로(제한해서 하나씩 처리하기 때문)  시스템 성능이 급격히 저
하되지 않는다.<br>
### [www.google.com](http://www.google.com)<br>
1. 브라우저는 사용자가 검색을 하는지 사이트 주소를 입력한 것인지 확인한다.(유효한 URL인지 검사)<br>
2. 주소를 입력했다면 해당 주소에 맞는 IP를 찾기 위해 DNS를 탐색하는 과정을 수행한다.<br>
* 브라우저의 캐시를 확인해 DNS기록을 확인한다.<br>
* 없다면 OS의 DNS 캐시를 확인한다.<br>
* 없다면 라우터의 DNS캐시를 확인한다.<br>
* 없다면 DNS서버에 쿼리를 날려 DNS에 해당하는 IP주소를 찾는 과정을 재귀적으로 
수행한다.ROOT"." -> TOP"com" -> SECOND"google" -> THIRD"www"<br>
3. 위의 과정을 통해 서버의 IP주소를 얻는다. 
4. 라우터를 통해 해당 서버의 게이트웨이까지 이동한 후 ARP프로세스를 거쳐 IP주소를 MAC주소로 변환한다.
5. 해당 서버와 TCP연결을 설정한다.<br>
6. 그 후에 HTTPS인 경우 TLS hadshake과정을 거친 후 HTTP요청을 서버에서 받게 된다.<br>
7. 서버에서는 Request 핸들러에 의해 요청에 관한 응답을 생성한다. <br>
8. 그 후에 클라이언트에게 생성한 응답을 보낸다.<br>
9. 브라우저는 응답에 맞추어 html 컨텐츠를 렌더링한다.<br>
* DNS Lookup 과정<br>
1. 브라우저의 캐시를 확인해 DNS기록을 확인한다.<br>
2. 없다면 OS의 DNS 캐시를 확인한다.<br>
3. 없다면 라우터의 DNS캐시를 확인한다.<br>
4. 없다면 DNS서버에 쿼리를 날려 DNS에 해당하는 IP주소를 찾는 과정을 재귀적으로 
수행한다.ROOT"." -> TOP"com" -> SECOND"google" -> THIRD"www"<br>
* 서버 전송은 어떻게 하나?<br>
### Statement, PreparedStatement<br>
Statement는 쿼리를 실행할때마다 매번 컴파일을 수행해야 하는 명령 문장이다.<br>
PreparedStatement란 데이터베이스 관리 시스템(DBMS)에서 동일하거나 비슷한 데이터베이스 문을 높은 효율성으로 반복적으로 실행하기 위해 사용되는 기능을 말할다.<br>
둘의 가장 큰 차이점은 캐시 사용 여부이다. PreparedStatement를 사용하면 쿼리를 캐시
에 담아두어 처음 한번만 컴파일과정을 거치며 쿼리문을 값만 바꾸면서 사용할 수 있다.
따라서 동일한 쿼리를 반복적으로 수행하게 된다면 PreparedStatement를 사용하는것이
데이터 베이스에 훨씬 적은 부하를 주며 성능도 좋다.<br>
### 서블릿이란 무엇인가?<br>
웹서버는 정적인 페이지만 전달했다. 하지만 사용자의 요청에 따라 동적으로 처리를 하는
웹 어플리케이션이 필요했고 이를 위해 CGI(Common Gateway Interface)라는 개념이
등장했다. PHP와같은 것들이 있다. 하지만 CGI는 클라이언트의 요청이 들어올때마다
프로세스 단위로 작업을 해 많은 사용자를 처리하기에는 무리가 있다는 제한점이 있다.
또한 같은 CGI구현체를 사용하더라도 요청마다 새로운 프로세스를 만들어 사용하였는데
이러한 CGI를 보완해서 만든것이 서블릿이다. 따라서 서블릿에서는 요청을 프로세스 단
위가 아닌 스레드 단위로 처리를 해서 훨씬 성능이 향상되었으며, 서블릿 객체에 대해서
싱글톤으로 관리해 요청마다 객체를 생성하는 행위를 하지 않는다.<br>
클라이언트에서 요청시 웹 컨테이너는 request별로 스레드를 생성하며, 생성된 스레드와
서블릿 구현체와 연동시키며 서블릿에 있는 메소드를 호출하는 역할을 한다.<br>
서블릿에는 크게 Init(생성), Service(실제 기능 수행), Destroy(삭제)의 메소드가 정의되어 있으며
abstract class HttpServlet extends Servlet객체를 생성하며 HTTP 메소드에 따라 doGet(), dPut(),
, doPost(), doDelete() 메서드를 호출한다. 각 메소드는 서블릿 컨테이너(TomCat)이 호출해준다.<br>

### CGI 구현체<br>
웹서버는 정적인 페이지만 전달했다. 하지만 사용자의 요청에 따라 동적으로 처리를 하는
웹 어플리케이션이 필요했고 이를 위해 CGI(Common Gateway Interface)라는 개념이
등장했다. PHP와같은 것들이 있다.
### **MVC 패턴**<br>
개발을 하다보면 유지보수를 해야하는 상황이 많이 있는데 이를 위해서 여러가지 패턴
이 등장했다. 그중에서 MVC라는 패턴이 유명해지게 됐다. 이때 M은 Model, V는 view,
C는 Controller라는 의미인데 각 의미별 하는 역할에 대해서 살펴보면<br>
Model은 데이터관련된 부분, Veiw는 사용자에게 보여지는 부분, Controller는 Model과
View를 이어주는 부분이라고 말할 수 있다. 예를들어 구글에 코딩이라고 검색을 하면
컨트롤러는 모델에 데이터를 달라고 요청을 하고, 받은 데이터를 View에게 전달을 한다.
View는 사용자가 보는 검색 결과에 데이터를 넣어서 웹페이지를 보여준다. 이것이 간략한
MVC패턴의 동작 과정이다. MVC패턴을 잘 지키기 위해서는 5가지 규칙을 지키면 된다.<br>
1. Model은 Controller와 View에 의존하지 않아야 한다,(Model 내부에 Controller와 View에 관련된 코드가 있으며 안된다.)
```
public class Car {
    private String name;
    private int num;

    public Car(String name, int num) {
        this.name = name;
        this.num = num;
    }

    public String getName() {
        return this.name;
    }

    public int getNum() {
        return this.num;
    }
}
```
2. View는 Model에만 의존해야 하고, Cotroller에는 의존하면 안된다.(View 내부에 Model의 코드만 있을 수 있고,
Controller의 코드가 있으면 안된다.)<br>
```
public class OutputView {
    public void PrintProfile(Car car) {
        System.out.println("차 이름은 " + car.getName() + "입니다.");
        System.out.println("차 번호는 " + car.getNum() + "입니다.");
    }
}
```
3. View가 Model로부터 데이터를 받을때는, 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야 한다.<br>
4. Controller는 Model과 View에 의존해도 된다.(Controller 내부에는 Model과 View의 코드가 있을 수 있다.)<br>
```
public class Controller {
    public static void main(String[] args) {
        Car car = new Car("아반떼", "41");
        OutputView.printProfile(car);
    }
}
```
5. View가 Model로부터 데이터를 받을때, 반드시 Controller에서 받아야 한다.<br>


